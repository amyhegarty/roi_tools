#!/usr/bin/env python
"""The run script."""
# Import packages
import pandas as pd
import numpy as np
import argparse
from functools import partial
import nilearn.image
from nilearn.image import index_img, iter_img
import sys, subprocess, os, datetime, logging
from nibabel.funcs import concat_images, four_to_three
import nibabel as nib
from pathlib import Path
from os.path import splitext
import posixpath as pp
from nipype.interfaces.fsl.maths import DilateImage

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
log = logging.getLogger(__name__)

# set version
__version__ = "0.0.1"


# define functions here...

def parser(context):
    # parse inputs similarly to cli ingest bids function

    def _path_exists(path, parser):
        """Ensure a given path exists."""
        if path is None or not Path(path).exists():
            raise parser.error(f"Path does not exist: <{path}>.")
        return Path(path).absolute()

    def _is_file(path, parser):
        """Ensure a given path exists and it is a file."""
        path = _path_exists(path, parser)
        if not path.is_file():
            raise parser.error(f"Path should point to a file (or symlink of file): <{path}>.")
        return path

    def _is_decimal(val, parser):
        """Ensure a given value is a value between 0 and 1."""
        val = float(val)
        if val < 0 or val > 1:
            raise parser.error(f"Entered value must be between 0 and 1")
        return val

    parser = argparse.ArgumentParser(
        description="Overlap Mapping Code is a tool used to set custom thresholds for a set of nifti images. Subject specific thresholds are generated by first setting a common critera for all images, then applying a custom threshold. A mask can also be provided to limit the \u201cscope\u201d of the threshold search to a certain brain area. This gives the  advantage that brain activation is scaled to ensure activation in regions of interest.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    PathExists = partial(_path_exists, parser=parser)
    IsFile = partial(_is_file, parser=parser)
    IsDecimal = partial(_is_decimal, parser=parser)

    ##########################
    #   Required Arguments   #
    ##########################
    parser.add_argument(
        "input-path",
        action="store",
        metavar="INPUT-PATH",
        type=PathExists,
        help="path to input 3D or 4D files to threshold"
    )
    parser.add_argument(
        "output-path",
        action="store",
        metavar="OUTPUT-PATH",
        type=PathExists,
        help="path to output directory location for results"
    )

    ##########################
    #   Optional Arguments   #
    ##########################
    parser.add_argument(
        "--quantile",
        action='store',
        type=IsDecimal,
        help="Use a quantile as the image threshold [values should be entered between 0-1]")
    parser.add_argument(
        "--mask",
        action="store",
        metavar="PATH",
        type=IsFile,
        help="path to 3D nifti image mask used to restrict threshold calculation"
    )
    parser.add_argument(
        "--dilate-kernel-type",
        action="store",
        metavar="TYPE",
        help="specify kernel type used to dilate the boarder of provided mask [options: 3D, 2D, box, boxv, gauss, sphere, file...]"
    )
    parser.add_argument(
        "--dilate-kernel-size",
        action="store",
        metavar="SIZE",
        default=0,
        help="specify kernel size used to dilate the boarder of provided mask, must be supplied with kernal types [box, boxv, gauss, sphere]"
    )
    parser.add_argument(
        "--dilate-kernel-file",
        action="store",
        metavar="PATH",
        default=0,
        help="specify external file as kernel"
    )
    parser.add_argument("-v", "--verbosity", action="count", default=0)

    args = parser.parse_args()

    if args.dilate_kernel_type and (args.mask is None):
        parser.error("--dilate-kernel-type must be defined with --mask")
    if args.dilate_kernel_type in ["3D", "2D", "file"] and args.dilate_kernel_size:
        parser.error("kernel method 3D, 2D or file cannot be defined with a kernel size")
    if args.dilate_kernel_type in ["box", "boxv", "gauss", "sphere"] and (args.dilate_kernel_size is None):
        parser.error("kernel method box, boxv, gauss, or sphere must be passed with a kernel size (--dilate-kernel-size)")
    if args.dilate_kernel_type not in ["3D", "2D", "file","box", "boxv", "gauss", "sphere"] and (args.dilate_kernel_type):
        parser.error("kernel method passed is not supported")
    if args.dilate_kernel_type in ["file"] and (args.dilate_kernel_file is None):
        parser.error("kernel method file must be passed with a kernel filepath")
    
    # add all args to context
    args_dict = args.__dict__
    context.update(args_dict)

    ##########################
    #    Argument Checks     #
    ##########################

    # check input-path and mask are both nifti image types
    if context["input-path"].is_dir():
        # assume if directory is passed you are looking for filtered_func_data.nii.gz
        context["input-path"] = context["input-path"] / "filtered_func_data.nii.gz"
        if not context["input-path"].exists():
            parser.error("Input path: %s not found.", str(context["input-path"]))
    if context["input-path"].is_file():
        if ".nii" not in str(context["input-path"]):
            parser.error("Input path: %s must be nifti file.", str(context["input-path"]))

    if args.mask:
        if ".nii" not in str(context["mask"]):
            parser.error("Mask path: %s must be nifti file.", str(context["mask"]))

    # reformat thresholding methods
    if args.quantile:
        context["method"] = "quantile"
        context["threshold"] = args.quantile

    else:
        log.info("No thresholding will be applied, exitting now.")
        sys.exit(0)
    # end parser


def main(context):
    """Entry point."""

    # parse user inputs and store in context
    parser(context)

    # load in input image
    log.info('Using file: %s for analysis', str(context["input-path"]))
    img = nilearn.image.load_img(str(context["input-path"]))

    nimgs = img.shape[3]
    log.debug('Using input image: %s', context["input-path"])
    log.debug('Number of inputs %s', nimgs)

    # pull 3D / 4D array from image
    data = nilearn.image.get_data(img)

    # initialize values
    new_data = np.zeros(img.shape)
    upper_thres = []
    lower_thres = []

    # if mask exists load it and dilate
    if context["mask"]:
        mask = dilatemask(context)

    for i in range(0, nimgs - 1):
        # pull each 3D image separately
        idx_data = data[:, :, :, i]

        # apply mask
        # TODO MAKE SURE MASK IS BINARY THEN MASK INPUT DATA
        if 'mask' in locals():
            # make sure mask is binary
            mask[mask != 0] = 1
            # mask input data
            idx_data = idx_data * mask

        # compute threshold
        thres_pos, thres_neg = computethreshold(idx_data, context["method"], context["threshold"])

        # apply threshold
        thres_data = data[:, :, :, i]
        thres_data[np.logical_and(thres_data <= thres_pos, thres_data >= thres_neg)] = 0

        # store data for output
        new_data[:, :, :, i] = thres_data
        upper_thres.append(thres_pos)
        lower_thres.append(thres_neg)

    # save outputs to file, start by pulling together single objects for file writing
    df = pd.DataFrame.from_dict({'upper': upper_thres, 'lower': lower_thres})
    
    # create collated image across all subjects (counter)
    pos_collate, neg_collate = collateresults(new_data)
    
    # create new output image
    results_img = nib.nifti1.Nifti1Image(new_data, affine=img.affine.copy(), header=img.header.copy())
    
    collated_pos_img = nib.nifti1.Nifti1Image(pos_collate, affine=img.affine.copy())
    
    collated_neg_img = nib.nifti1.Nifti1Image(neg_collate, affine=img.affine.copy())
    
    # save outputs
    saveoutputs(context, results_img, collated_pos_img, collated_neg_img, df)


def computethreshold(arr, method, stat):
    """Compute the threshold for a 3D image, based on provided method (e.g. quantile), and threshold stat

    Args:
        arr (3D numpy array): image data used to compute a method based threshold (e.g. quantile)
        method (str): method to apply, currently only support "quantile"
        stat (float): value used with the method described above to set custom image threshold
    """

    if method.lower() == "quantile":
        thres_pos = np.quantile(arr[arr > 0], stat)
        thres_neg = -np.quantile(np.abs(arr[arr < 0]), stat)
    else:
        log.error("Currently only quantile based thresholding is supported. Come back later!")

    return [thres_pos, thres_neg]

def collateresults(data):
    # create positive only array
#     pos_data = np.copy(data)
#     pos_data[data < 0] = 0
#     pos_collate = np.count_nonzero(pos_data, axis=3)
    pos_collate = np.sum(np.array(data) > 0, axis=3)
    
    # create negative only array
#     neg_data = np.copy(data)
#     neg_data = np.minimum(data, 0)
# #     neg_data[data > 0] = 0
#     neg_collate = np.count_nonzero(neg_data, axis=3)
    neg_collate = np.sum(np.array(data) < 0, axis=3)
    
    return [pos_collate, neg_collate]

def saveoutputs(params, outimage, posimg, negimg, outcsv):
    """Save output nifti image and output list of subject specific thresholds. Save to output path provided by inputs

    Args:
        params (dictionary): organized inputs from parser
        outimage (NiftiImage1): nifti image to be saved
        posimg (NiftiImage1): nifti image to be saved
        negimg (NiftiImage1): nifti image to be saved
        outcsv (dataframe): values to be stored in csv tracking threshold used for each image
    """
    # set output path and filenames
    suffix = "_Q" + str(params["threshold"]).replace(".","") + ".nii.gz"
    outputfilename = pp.basename(params["input-path"]).split('.')[0] + suffix
    path = params["output-path"]

    # write outputs to a predetermined location...
    os.system('mkdir -p ' + os.path.dirname(path))
    outimage.to_filename(os.path.join(str(path), outputfilename))
    log.info('Result image saved: %s', os.path.join(str(path), outputfilename))
    
    posimg.to_filename(os.path.join(str(path), outputfilename.replace('.nii.gz', '_pos_collated.nii.gz')))
    log.info('Result image saved: %s', os.path.join(str(path), outputfilename.replace('.nii.gz', '_pos_collated.nii.gz')))

    negimg.to_filename(os.path.join(str(path), outputfilename.replace('.nii.gz', '_neg_collated.nii.gz')))
    log.info('Result image saved: %s', os.path.join(str(path), outputfilename.replace('.nii.gz', '_neg_collated.nii.gz')))
    
    # write threshold values also
    outcsv.to_csv(os.path.join(str(path), outputfilename.replace('.nii.gz', '.csv')))
    log.info('Thresholds used stored %s', os.path.join(str(path), outputfilename.replace('.nii.gz', '.csv')))


def dilatemask(context):

    # fslmaths lesioning approaches (3D, 2D, gaus, etc).
    if context["dilate_kernel_type"]:
        if context["dilate_kernel_type"] in ['3D', '2D', 'box', 'boxv', 'gauss', 'sphere']:
            dilate = DilateImage()
            dilate.inputs.in_file = context['mask']
            dilate.inputs.operation = 'mean'
            dilate.inputs.kernel_shape = context["dilate_kernel_type"]
            if context["dilate_kernel_type"] in ['3D', '2D']:
                pass   # no other inputs should be given
            elif context["dilate_kernel_type"] in ['box', 'boxv', 'gauss', 'sphere']:
                 # a single size argument should be passed
                dilate.inputs.kernel_size = float(context["dilate_kernel_size"]) 
            elif context["dilate_kernel_type"] in ['file', 'boxv3']:
                log.error("Kernel type %s currently not supported", context["dilate_kernel_type"])
            dilate.inputs.out_file = 'tmp.nii.gz'
            cmd = dilate.cmdline
            log.info(cmd)

            # run dilate
            dilate.run()
            new_mask = nilearn.image.load_img('tmp.nii.gz')
            os.system('rm tmp.nii.gz')
        else:
            log.error("Dilate kernel is not supported: %s come back later!", context["dilate_kernel_type"])
    else:
        new_mask = nilearn.image.load_img(str(context['mask']))
    
    outdata = nilearn.image.get_data(new_mask)

    return outdata


# Only execute if file is run as main, not when imported by another module
if __name__ == "__main__":  # pragma: no cover

    pycontext = dict()

    main(pycontext)

